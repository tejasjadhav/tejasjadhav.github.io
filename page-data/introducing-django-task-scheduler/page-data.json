{"componentChunkName":"component---src-templates-blog-post-js","path":"/introducing-django-task-scheduler/","result":{"data":{"site":{"siteMetadata":{"title":"Tejas Jadhav"}},"mdx":{"id":"7b332c05-da18-5260-bc6e-ecbbe2c8206e","excerpt":"Scheduler is a small task scheduling utility built for Django using Celery. A lot of interesting projects start by solving a simple but essential problems ofâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Introducing: Scheduler\",\n  \"slug\": \"/introducing-django-task-scheduler\",\n  \"date\": \"2018-11-25T02:54:52.000Z\",\n  \"featured\": false,\n  \"draft\": false,\n  \"tags\": [\"python\", \"programming\", \"project\", \"library\", \"scheduler\", \"django\", \"celery\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Scheduler is a small task scheduling utility built for Django using Celery.\"), mdx(\"p\", null, \"A lot of interesting projects start by solving a simple but essential problems of some other major problem. So was the case with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/tejasjadhav/django-scheduler\"\n  }), \"Scheduler\"), \". At \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mpaani.com\"\n  }), \"m.Paani\"), \", I had similar such problem.\"), mdx(\"h1\", null, \"Problem statement\"), mdx(\"p\", null, \"I had to execute a task at specific intervals. At first, I tried the one and only, fan-favorite, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cronjob\"), \". Luckily, Celery has something which does the exact same thing - \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"@periodic_task\"), \". Just enter your cron rule and your job is done. Voila! Problem solved. Celebrations were too early and I just discovered a few scenarios which could not be done with cron jobs alone.\"), mdx(\"p\", null, \"To understand this, let\\u2019s see how a complicated rule of our old, faithful cron looks like.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"cron\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-cron\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cron\"\n  }), \"5-30/3 */2 * 1,5,9 2\"))), mdx(\"p\", null, \"The above rule translates to,\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"At every 3rd minute from 5 through 30 past every 2nd hour on Tuesday in January, May, and September. \", mdx(\"small\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://crontab.guru/\"\n  }), \"crontab.guru\"), \". You can check the interpretation of the above rule \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://crontab.guru/#5-30/3_*/2_*_1,5,9_2_\"\n  }), \"here\"), \".\"))), mdx(\"p\", null, \"This seems all nice and fair. However, I had some bizaare use cases.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Task should execute every 2nd Friday\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Task should execute on second last day on every month\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Task should execute on every even day\")), mdx(\"p\", null, \"Cron rule for first is still manageable in some cases. For second, it is impossible. And for 3rd, it fails after every month with odd number of days (though the non-standard way of doing it is \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"0 0 2/2 * *\"), \"). After head banging for a day and countless Google searches, I just glanced at my \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://play.google.com/store/apps/details?id=com.google.android.calendar&hl=en\"\n  }), \"calendar app\"), \" and saw some recurring events, like weekly sprints, month-end discussions, etc. When I tried to create one with a repetition pattern, I saw half a dozen of configurations. Initially, it seemed like some Google kinda stuff (of course, you can only expect such sophistications from a Google-like company). But, then I saw similar settings on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://wiki.gnome.org/Apps/Evolution\"\n  }), \"Evolution\"), \". To my utter surprise, I could edit the reccurence rules set for the event on Google Calendar, and then on the app, those changes got sync\\u2019d up. This commonality means that there\\u2019s some practice or convention followed by both. After digging about it for some time, I hit the jackpot. It\\u2019s called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Recurrence Rules\"), \" which is an actual \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://tools.ietf.org/html/rfc2445\"\n  }), \"standard set by the IEFT\"), \" (the gods behind everything related to internet including HTTP, LDAP, sockets, etc. You can check the list of standards they have in place \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.rfc-editor.org/rfc-index.html\"\n  }), \"here\"), \".)\"), mdx(\"h1\", null, \"Recurrence rules \", mdx(\"em\", {\n    parentName: \"h1\"\n  }, \"(RRULE)\")), mdx(\"p\", null, \"They are similar to cron jobs. Like cron, they solve the problem of defining rules for programming date and time patterns. Unlike cron, RRULE is a complete \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://blog.tejasjadhav.xyz/2016/06/06/domain-specific-languages-using-python-part-1/\"\n  }), \"DSL\"), \" with limited grammar. You can stack multiple RRULEs to create an inclusion-exclusion pattern. Look at this example below,\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"rrule\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-rrule\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rrule\"\n  }), \"RRULE:FREQ=DAILY;COUNT=5\"))), mdx(\"p\", null, \"The above rule executes every day for the next 5 days. Not amused, take another example,\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"rrule\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-rrule\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rrule\"\n  }), \"RRULE:FREQ=MONTHLY;COUNT=3;BYDAY=-2MO\"))), mdx(\"p\", null, \"This rule executes every second last day of the month for the next 3 months. Sounds familiar? Yes, this solves my second use case too.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"rrule\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-rrule\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rrule\"\n  }), \"RRULE:FREQ=DAILY;INTERVAL=2;BYSETPOS=2\"))), mdx(\"h1\", null, \"Implementation\"), mdx(\"p\", null, \"One by one, all my usecases were handled by RRULEs. But building a complete RRULE parser in Python is a prodigious chore. I had written an article about writing DSLs in Python a while back which you may refer to understand how much does it take to build a basic DSL. This was just too much for me to do. I almost settled for cronjobs again when I realised that the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://pypi.python.org/pypi/python-dateutil\"\n  }), mdx(\"code\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"python-dateutil\")), \" library has something already built related to RRULEs. Oh yes! They had built an RRULE parser (\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://dateutil.readthedocs.io/en/stable/rrule.html\"\n  }), mdx(\"code\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"dateutil.rrule\")), \") which, in fact, also has a Python API giving an even greater control of the individual elements of the RRULE. Such a sweet delight!\"), mdx(\"p\", null, \"The library has a function \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"dateutil.rrule.rrulestr\"), \" which converts a raw RRULE string into a \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" object. The best part about this object is, some parameters of the RRULE can be changed directly by modifying the object properties, like the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"dtstart\"), \" parameter. Also, the best part is, the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" object is a generator, which means I can iterate over it and it will give me the next timestamp in the sequence. Overall, this utility provided the perfect suite for managing RRULEs.\"), mdx(\"p\", null, \"Th initial idea for flow was,\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Get the RRULEs from the database defined by the user\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Build the \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" object\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Get the next timestamp in the sequence\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Pickle the \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" object and store it in the database and execute the function at the specified timestamp using the \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"eta\"), \" argument in Celery\\u2019s \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"apply_async\"), \" function.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When the function gets executed, unpickle the \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" object, get the next timestamp and then repeat step 4.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Repeat until \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" no longer returns a timestamp.\")), mdx(\"p\", null, \"However, there was one major issue. The \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" object was \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.python.org/3.7/library/pickle.html#pickle-picklable\"\n  }), \"unpickable\"), \". Further I realised, the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" object was not a generator but an iterator instead. A workaround for this (a hack!) was to get the time when the function last executed and keep fetching the next timestamp from the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" iterator until the next timestamp was greater than the current one. Since I no longer had to pickle the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rrule\"), \" object, I just stored the last executed timestamp in the database which, in my opinion, is a much cleaner solution and much more library agnostic.\"), mdx(\"p\", null, \"Also, I didn\\u2019t want to interfere with the usual way Celery works and wanted this flow to be introduced with as little custom code as possible. So, instead of creating a new task decorator, I preferred \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://docs.celeryproject.org/en/latest/userguide/tasks.html#task-inheritance\"\n  }), \"Celery\\u2019s task inheritence\"), \" and created a base task class called \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"RepeatTask\"), \" which contained the entire logic for fetching the function, fetching the arguments and keyword arguments, executing the function, getting the next timestamp and then scheduling the task for next execution.\"), mdx(\"p\", null, \"I\\u2019ve added the installation and usage details in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/tejasjadhav/django-scheduler/blob/master/README.md\"\n  }), \"README\"), \" of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/tejasjadhav/django-scheduler/\"\n  }), \"repository\"), \". Please check it out. The library is still in alpha and yet to be published on PyPI.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Introducing: Scheduler","date":"November 25, 2018"}}},"pageContext":{"slug":"/introducing-django-task-scheduler/","previous":{"fields":{"slug":"/importing-mi-notebook-air-a-nightmare/"},"frontmatter":{"title":"Importing Mi Notebook Air: A nightmare and an episode with the customs"}},"next":{"fields":{"slug":"/squashing-bugs-when-datetime-comparisons-go-wrong/"},"frontmatter":{"title":"Squashing bugs: When datetime comparisons go wrong"}}}}}